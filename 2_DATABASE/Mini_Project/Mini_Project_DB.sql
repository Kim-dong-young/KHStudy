DROP TABLE TB_SHARE;
DROP TABLE TB_COMMENT;
DROP TABLE TB_BULLETIN;
DROP TABLE TB_MEMBER_ITEM;
DROP TABLE TB_ITEM;
DROP TABLE TB_TRADELOG;
DROP TABLE TB_MEMBER_STOCK;
DROP TABLE TB_MEMBER;
DROP TABLE TB_MEMBER_RANK;
DROP TABLE TB_STOCK_LIST;

--================== 테이블 생성  ======================
CREATE TABLE "TB_MEMBER" (
  "MEMBER_UID" NUMBER CONSTRAINT TB_MEMBER_PK PRIMARY KEY,
  "MEMBER_NAME" VARCHAR2(30),
  "MEMBER_ID" VARCHAR2(20) CONSTRAINT MEMBER_ID_UQ UNIQUE CONSTRAINT MEMBER_ID_NN NOT NULL,
  "MEMBER_PWD" VARCHAR2(30) CONSTRAINT MEMBER_PWD_NN NULL,
  "MEMBER_RCODE" VARCHAR2(5) DEFAULT 'M1',
  "ENROLL_DATE" DATE DEFAULT SYSDATE,
  "WITHDRAW_YN" CHAR(1) DEFAULT 'N' CONSTRAINT WITHDRAW_YN_CK CHECK(WITHDRAW_YN IN ('Y','N')),
  "PLAY_DAY" NUMBER DEFAULT 0,
  "BALANCE" NUMBER DEFAULT 1000000
);

COMMENT ON COLUMN TB_MEMBER.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_MEMBER.MEMBER_NAME IS '멤버 이름';
COMMENT ON COLUMN TB_MEMBER.MEMBER_ID IS '멤버 아이디';
COMMENT ON COLUMN TB_MEMBER.MEMBER_PWD IS '멤버 비밀번호';
COMMENT ON COLUMN TB_MEMBER.MEMBER_RCODE IS '멤버 등급번호';
COMMENT ON COLUMN TB_MEMBER.ENROLL_DATE IS '멤버 가입일';
COMMENT ON COLUMN TB_MEMBER.WITHDRAW_YN IS '멤버 탈퇴여부';
COMMENT ON COLUMN TB_MEMBER.PLAY_DAY IS '게임 내 날짜';
COMMENT ON COLUMN TB_MEMBER.BALANCE IS '멤버 재산(현금)';

CREATE TABLE "TB_MEMBER_RANK" (
  "MEMBER_RCODE" VARCHAR2(5) CONSTRAINT TB_MEMBER_RANK_PK PRIMARY KEY,
  "MEMBER_RNAME" VARCHAR2(30)
);

COMMENT ON COLUMN TB_MEMBER_RANK.MEMBER_RCODE IS '멤버 등급번호';
COMMENT ON COLUMN TB_MEMBER_RANK.MEMBER_RNAME IS '멤버 등급이름';

CREATE TABLE "TB_STOCK_LIST" (
  "STOCK_ID" NUMBER CONSTRAINT TB_STOCK_LIST_PK PRIMARY KEY,
  "STOCK_NAME" VARCHAR2(50) CONSTRAINT STOCK_NAME_UQ UNIQUE,
  "DEFAULT_PRICE" NUMBER DEFAULT 100000,
  "DEFAULT_QTY" NUMBER DEFAULT 1000,
  "DELIST_YN" CHAR(1) DEFAULT 'N' CONSTRAINT DELIST_YN_CK CHECK(DELIST_YN IN('Y','N'))
);

COMMENT ON COLUMN TB_STOCK_LIST.STOCK_ID IS '주식 번호(시퀀스)';
COMMENT ON COLUMN TB_STOCK_LIST.STOCK_NAME IS '주식 이름';

-- 모의주식 "게임"으로, 주식가격은 멤버별로 공유하지 않는다.
CREATE TABLE "TB_MEMBER_STOCK"(
    "STOCK_ID" NUMBER,
    "MEMBER_UID" NUMBER,
    "MAX_QTY" NUMBER DEFAULT 0,
    "STOCK_QTY" NUMBER DEFAULT 0,
    "STOCK_PRICE" NUMBER DEFAULT 0,
    "NEXT_FLUCT" NUMBER DEFAULT 0,
    CONSTRAINT TB_MEMBER_STOCK_PK PRIMARY KEY(STOCK_ID, MEMBER_UID)
);

COMMENT ON COLUMN TB_MEMBER_STOCK.STOCK_ID IS '주식 번호(시퀀스)';
COMMENT ON COLUMN TB_MEMBER_STOCK.MAX_QTY IS '주식 최대 수량';
COMMENT ON COLUMN TB_MEMBER_STOCK.STOCK_QTY IS '시장에 나온 현재 주식 수량';
COMMENT ON COLUMN TB_MEMBER_STOCK.STOCK_PRICE IS '주식 가격';
COMMENT ON COLUMN TB_MEMBER_STOCK.NEXT_FLUCT IS '다음날 가격 변동률';

CREATE TABLE "TB_SHARE" (
  "MEMBER_UID" NUMBER,
  "STOCK_ID" NUMBER,
  "SHARE_QTY" NUMBER DEFAULT 0,
  "PURCHASE_PRICE" NUMBER DEFAULT 0,
  CONSTRAINT TB_SHARE_PK PRIMARY KEY ("MEMBER_UID", "STOCK_ID")
);

COMMENT ON COLUMN TB_SHARE.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_SHARE.STOCK_ID IS '주식 번호(시퀀스)';
COMMENT ON COLUMN TB_SHARE.SHARE_QTY IS '주식 보유량';
COMMENT ON COLUMN TB_SHARE.PURCHASE_PRICE IS '주식 매입가';

CREATE TABLE "TB_TRADELOG" (
  "TRADE_ID" NUMBER CONSTRAINT TB_TRADELOG_PK PRIMARY KEY,
  "MEMBER_UID" NUMBER,
  "TRADE_DATE" DATE DEFAULT SYSDATE,
  "STOCK_ID" NUMBER,
  "TRADE_QTY" NUMBER CONSTRAINT TRADE_QTY_NN NOT NULL,
  "TRADE_PRICE" NUMBER CONSTRAINT TRADE_PRICE_NN NOT NULL,
  "TRADE_STATUS" VARCHAR2(9) CONSTRAINT TRADE_STATUS NOT NULL
);

COMMENT ON COLUMN TB_TRADELOG.TRADE_ID IS '거래 번호(시퀀스)';
COMMENT ON COLUMN TB_TRADELOG.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_TRADELOG.TRADE_DATE IS '거래 일자';
COMMENT ON COLUMN TB_TRADELOG.STOCK_ID IS '주식 이름';
COMMENT ON COLUMN TB_TRADELOG.TRADE_QTY IS '거래 수량';
COMMENT ON COLUMN TB_TRADELOG.TRADE_PRICE IS '거래 가격';
COMMENT ON COLUMN TB_TRADELOG.TRADE_STATUS IS '상태(판매/구매)';

CREATE TABLE "TB_BULLETIN" (
  "BULLETIN_ID" NUMBER CONSTRAINT TB_BULLETIN_PK PRIMARY KEY,
  "BULLETIN_VCOUNT" NUMBER DEFAULT 0,
  "BULLETIN_WRT_DATE" DATE DEFAULT SYSDATE,
  "MEMBER_UID" NUMBER,
  "BULLETIN_TITLE" VARCHAR2(90),
  "BULLETIN_CONTENT" VARCHAR2(1500),
  "BULLETIN_DLT_YN" CHAR(1) DEFAULT 'N' CONSTRAINT BULLETIN_DLT_YN_CK CHECK( BULLETIN_DLT_YN IN ('Y','N') )
);

COMMENT ON COLUMN TB_BULLETIN.BULLETIN_ID IS '게시글 번호(시퀀스)';
COMMENT ON COLUMN TB_BULLETIN.BULLETIN_VCOUNT IS '게시글 조회수';
COMMENT ON COLUMN TB_BULLETIN.BULLETIN_WRT_DATE IS '게시글 작성일자';
COMMENT ON COLUMN TB_BULLETIN.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_BULLETIN.BULLETIN_TITLE IS '게시글 제목';
COMMENT ON COLUMN TB_BULLETIN.BULLETIN_CONTENT IS '게시글 내용';
COMMENT ON COLUMN TB_BULLETIN.BULLETIN_DLT_YN IS '게시글 삭제여부(Y/N)';

CREATE TABLE "TB_COMMENT" (
  "BULLETIN_ID" NUMBER,
  "COMMENT_ID" NUMBER,
  "COMMENT_WRT_DATE" DATE DEFAULT SYSDATE,
  "MEMBER_UID" NUMBER,
  "COMMENT_CONTENT" VARCHAR2(300),
  "COMMENT_DLT_YN" CHAR(1) DEFAULT 'N' CONSTRAINT COMMENT_DLT_YN_CK CHECK( COMMENT_DLT_YN IN ('Y','N') ),
  CONSTRAINT TB_COMMENT_PK PRIMARY KEY("BULLETIN_ID","COMMENT_ID")
);

COMMENT ON COLUMN TB_COMMENT.BULLETIN_ID IS '게시글 번호(시퀀스)';
COMMENT ON COLUMN TB_COMMENT.COMMENT_ID IS '댓글 번호';
COMMENT ON COLUMN TB_COMMENT.COMMENT_WRT_DATE IS '댓글 작성일자';
COMMENT ON COLUMN TB_COMMENT.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_COMMENT.COMMENT_CONTENT IS '댓글 내용';
COMMENT ON COLUMN TB_COMMENT.COMMENT_DLT_YN IS '댓글 삭제여부(Y/N)';

CREATE TABLE "TB_ITEM" (
  "ITEM_ID" NUMBER CONSTRAINT TB_ITEM_PK PRIMARY KEY,
  "ITEM_NAME" VARCHAR2(30),
  "ITEM_PRICE" NUMBER DEFAULT 0,
  "ITEM_DESC" VARCHAR2(600)
);

COMMENT ON COLUMN TB_ITEM.ITEM_ID IS '아이템 번호(시퀀스)';
COMMENT ON COLUMN TB_ITEM.ITEM_NAME IS '아이템 이름';
COMMENT ON COLUMN TB_ITEM.ITEM_PRICE IS '아이템 가격';
COMMENT ON COLUMN TB_ITEM.ITEM_DESC IS '아이템 설명';

CREATE TABLE "TB_MEMBER_ITEM" (
  "MEMBER_UID" NUMBER,
  "ITEM_ID" NUMBER,
  "ITEM_QTY" NUMBER DEFAULT 0,
  CONSTRAINT TB_MEMBER_ITEM_PK PRIMARY KEY ("MEMBER_UID", "ITEM_ID")
);

COMMENT ON COLUMN TB_MEMBER_ITEM.MEMBER_UID IS '멤버UID(시퀀스)';
COMMENT ON COLUMN TB_MEMBER_ITEM.ITEM_ID IS '아이템 번호(시퀀스)';
COMMENT ON COLUMN TB_MEMBER_ITEM.ITEM_QTY IS '아이템 보유수량';

-- ==================== 외래키 설정 =======================

ALTER TABLE "TB_MEMBER" ADD CONSTRAINT MEMBER_RCODE_FK 
FOREIGN KEY ("MEMBER_RCODE") REFERENCES "TB_MEMBER_RANK" ("MEMBER_RCODE");

ALTER TABLE "TB_SHARE" ADD CONSTRAINT TB_SHARE_MEMBER_UID_FK 
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_SHARE" ADD CONSTRAINT TB_SHARE_STOCK_ID_FK 
FOREIGN KEY ("STOCK_ID") REFERENCES "TB_STOCK_LIST" ("STOCK_ID")
ON DELETE CASCADE;

ALTER TABLE "TB_TRADELOG" ADD CONSTRAINT TB_TRADELOG_MEMBER_UID_FK 
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_TRADELOG" ADD CONSTRAINT TB_TRADELOG_STOCK_ID_FK 
FOREIGN KEY ("STOCK_ID") REFERENCES "TB_STOCK_LIST" ("STOCK_ID")
ON DELETE CASCADE;

ALTER TABLE "TB_BULLETIN" ADD CONSTRAINT TB_BULLETIN_MEMBER_UID_FK 
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_COMMENT" ADD CONSTRAINT TB_COMMENT_BULLETIN_ID_FK 
FOREIGN KEY ("BULLETIN_ID") REFERENCES "TB_BULLETIN" ("BULLETIN_ID")
ON DELETE CASCADE;

ALTER TABLE "TB_COMMENT" ADD CONSTRAINT TB_COMMENT_MEMBER_UID_FK 
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_MEMBER_ITEM" ADD CONSTRAINT TB_MEMBER_ITEM_ITEM_ID_FK 
FOREIGN KEY ("ITEM_ID") REFERENCES "TB_ITEM" ("ITEM_ID")
ON DELETE CASCADE;

ALTER TABLE "TB_MEMBER_ITEM" ADD CONSTRAINT TB_MEMBER_ITEM_MEMBER_UID_FK 
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_MEMBER_STOCK" ADD CONSTRAINT TB_MEMBER_STOCK_MEMBER_UID_FK
FOREIGN KEY ("MEMBER_UID") REFERENCES "TB_MEMBER" ("MEMBER_UID")
ON DELETE CASCADE;

ALTER TABLE "TB_MEMBER_STOCK" ADD CONSTRAINT TB_MEMBER_STOCK_STOCK_ID_FK
FOREIGN KEY ("STOCK_ID") REFERENCES "TB_STOCK_LIST" ("STOCK_ID")
ON DELETE CASCADE;

-- ================ 시퀀스 생성 ====================

DROP SEQUENCE MEMBER_UID_SEQ;
DROP SEQUENCE STOCK_ID_SEQ;
DROP SEQUENCE TRADE_ID_SEQ;
DROP SEQUENCE BULLETIN_ID_SEQ;
DROP SEQUENCE ITEM_ID_SEQ;

CREATE SEQUENCE MEMBER_UID_SEQ;
CREATE SEQUENCE STOCK_ID_SEQ;
CREATE SEQUENCE TRADE_ID_SEQ;
CREATE SEQUENCE BULLETIN_ID_SEQ;
CREATE SEQUENCE ITEM_ID_SEQ;
-- COMMENT_ID 시퀀스는 트리거로 게시글 별로 다르게 관리한다.

-- ================ 트리거 설정 ====================

-- COMMENT_ID 시퀀스 생성 ( 게시글마다 1부터 생성 )
CREATE OR REPLACE TRIGGER COMMENT_ID_TRG
BEFORE INSERT ON TB_COMMENT
FOR EACH ROW
DECLARE 
    SEQ_NUM NUMBER;
BEGIN
    SELECT NVL(MAX(COMMENT_ID),0) + 1 
    INTO SEQ_NUM
    FROM TB_COMMENT
    WHERE "BULLETIN_ID" = :NEW.BULLETIN_ID;
    
    :NEW.COMMENT_ID := SEQ_NUM;
END;
/

-- SET DEFAULT MEMBER_RCODE
CREATE OR REPLACE TRIGGER MEMBER_RANK_DEFAULT_TRG
BEFORE DELETE ON TB_MEMBER_RANK
FOR EACH ROW
BEGIN
    UPDATE TB_MEMBER
    SET MEMBER_RCODE = 'M1'
    WHERE MEMBER_RCODE = :OLD.MEMBER_RCODE;
END;
/

-- 멤버별 주식 종목 생성
CREATE OR REPLACE TRIGGER MEMBER_STOCK_TRG
AFTER INSERT ON TB_MEMBER
FOR EACH ROW
BEGIN
    FOR STOCK IN ( SELECT STOCK_ID, DEFAULT_PRICE, DEFAULT_QTY FROM TB_STOCK_LIST )
    LOOP
        INSERT INTO TB_MEMBER_STOCK 
        VALUES(
            STOCK.STOCK_ID, 
            :NEW.MEMBER_UID, 
            STOCK.DEFAULT_QTY, 
            STOCK.DEFAULT_QTY, 
            STOCK.DEFAULT_PRICE, 
            ROUND(DBMS_RANDOM.VALUE(0.8,1.2),2)
        );
    END LOOP;
END;
/

-- =============== 프로시저 생성 ======================
-- https://m.blog.naver.com/hj_kim97/222842014255

-- 주식 구매 프로시저
CREATE OR REPLACE PROCEDURE PURCHASE_STOCK_PROC (
    p_member_uid IN NUMBER,
    p_stock_id IN NUMBER,
    p_purchase_qty IN NUMBER,
    p_purchase_price IN NUMBER
) AS
    ms_stock_qty TB_MEMBER_STOCK.STOCK_QTY%TYPE;
    m_balance TB_MEMBER.BALANCE%TYPE;
BEGIN
    -- 변수 초기화 
    -- 1) 조건검사를 위해 주식 수량을 가져온다.
    SELECT STOCK_QTY
    INTO ms_stock_qty
    FROM TB_MEMBER_STOCK
    WHERE MEMBER_UID = p_member_uid
        AND STOCK_ID = p_stock_id;
        
    -- 2) 조건검사를 위해 보유한 돈을 가져온다.
    SELECT BALANCE
    INTO m_balance
    FROM TB_MEMBER
    WHERE MEMBER_UID = p_member_uid;
       
     -- 조건 검사 
     -- 1) 주식 시장에 물량이 충분한지 확인한다
     IF ms_stock_qty < p_purchase_qty 
        THEN RAISE_APPLICATION_ERROR(-20001,'주식 물량이 부족합니다.');
     END IF;
     
     -- 2) 보유한 돈을 확인한다.
     IF m_balance < p_purchase_price
        THEN RAISE_APPLICATION_ERROR(-20003,'보유한 돈이 부족합니다.');
     END IF;

    -- 1. TB_SHARE에서 사용자가 구매한 주식을 등록시키되, 만약 이미 있다면 주식의 수량 STOCK_QTY를 증가
    MERGE
    INTO TB_SHARE
    USING (SELECT p_stock_id AS STOCK_ID , p_member_uid AS MEMBER_UID FROM DUAL) SH
    ON (TB_SHARE.STOCK_ID = SH.STOCK_ID AND TB_SHARE.MEMBER_UID = SH.MEMBER_UID)
    WHEN MATCHED THEN
        UPDATE SET TB_SHARE.SHARE_QTY = TB_SHARE.SHARE_QTY + p_purchase_qty
    WHEN NOT MATCHED THEN
        INSERT VALUES(SH.MEMBER_UID , SH.STOCK_ID, p_purchase_qty, p_purchase_price);
        
     -- 2. p_purchase_qty 만큼 p_stock_id의 TB_MEMBER_STOCK.STOCK_QTY를 차감
    UPDATE TB_MEMBER_STOCK
    SET STOCK_QTY = STOCK_QTY - p_purchase_qty
    WHERE MEMBER_UID = p_member_uid 
        AND STOCK_ID = p_stock_id;
    
    -- 3. 구매 기록을 TB_TRADELOG에 등록
    INSERT INTO TB_TRADELOG VALUES(TRADE_ID_SEQ.NEXTVAL, p_member_uid, DEFAULT,
                                    p_stock_id, p_purchase_qty, p_purchase_price, '구매');
        
    -- 4. p_purchase_price 만큼 p_member_uid의 TB_MEMBER.BALANCE를 차감
    UPDATE TB_MEMBER
    SET BALANCE = BALANCE - p_purchase_price
    WHERE MEMBER_UID = p_member_uid;

END;
/

-- 주식 판매 프로시저
CREATE OR REPLACE PROCEDURE SELL_STOCK_PROC (
    p_member_uid IN NUMBER,
    p_stock_id IN NUMBER,
    p_sell_qty IN NUMBER,
    p_sell_price IN NUMBER
) AS
    s_share_qty TB_SHARE.SHARE_QTY%TYPE;
BEGIN 
    -- 변수 초기화 // 조건검사를 위해 주식 수량을 가져온다.
    SELECT SHARE_QTY 
    INTO s_share_qty 
    FROM TB_SHARE 
    WHERE MEMBER_UID = p_member_uid
        AND STOCK_ID = p_stock_id;
        
     -- 조건 검사 : 보유한 주식 물량보다 더 많이 팔려고 시도하는지 검사한다.
     IF s_share_qty < p_sell_qty 
        THEN RAISE_APPLICATION_ERROR(-20002,'주식 보유량이 부족합니다.');
     END IF;

    -- 1. 보유한 주식(TB_SHARE)에서 판매한 수량만큼 차감
    UPDATE TB_SHARE
    SET SHARE_QTY = SHARE_QTY - p_sell_qty
    WHERE MEMBER_UID = p_member_uid
        AND STOCK_ID = p_stock_id;
        
    -- 1_1. 보유한 주식 수량이 0이면 TB_SHARE 목록에서 제거
    DELETE FROM TB_SHARE
    WHERE SHARE_QTY <= 0;
        
    -- 2. 판매한 수량만큼 TB_MEMBER_STOCK의 STOCK_QTY 증가
    UPDATE TB_MEMBER_STOCK
    SET STOCK_QTY = STOCK_QTY + p_sell_qty
    WHERE MEMBER_UID = p_member_uid
        AND STOCK_ID = p_stock_id;
        
    -- 3. 판매 기록을 TB_TRADELOG에 등록
    INSERT INTO TB_TRADELOG VALUES(TRADE_ID_SEQ.NEXTVAL, p_member_uid, DEFAULT, 
                                    p_stock_id, p_sell_qty, p_sell_price, '판매');
    
    -- 4. 판매한 금액만큼 TB_MEMBER의 BALANCE 증가
    UPDATE TB_MEMBER
    SET BALANCE = BALANCE + p_sell_price
    WHERE MEMBER_UID = p_member_uid;
    
END;
/

-- 아이템 구매 프로시저
CREATE OR REPLACE PROCEDURE BUY_ITEM_PROC(
    p_member_uid IN NUMBER,
    p_item_id IN NUMBER
) AS
    m_balance TB_MEMBER.BALANCE%TYPE;
    m_item_price TB_ITEM.ITEM_PRICE%TYPE;
BEGIN
    SELECT BALANCE
    INTO m_balance
    FROM TB_MEMBER
    WHERE MEMBER_UID = p_member_uid;
    
    SELECT ITEM_PRICE
    INTO m_item_price
    FROM TB_ITEM
    WHERE ITEM_ID = p_item_id;

    IF m_balance < m_item_price 
        THEN RAISE_APPLICATION_ERROR(-20003,'보유한 돈이 부족합니다.');
    END IF;

    MERGE
    INTO TB_MEMBER_ITEM
    USING (SELECT p_member_uid AS MEMBER_UID, p_item_id AS ITEM_ID FROM DUAL) MI
    ON (TB_MEMBER_ITEM.MEMBER_UID = MI.MEMBER_UID AND TB_MEMBER_ITEM.ITEM_ID = MI.ITEM_ID)
    WHEN MATCHED THEN
        UPDATE SET TB_MEMBER_ITEM.ITEM_QTY = TB_MEMBER_ITEM.ITEM_QTY + 1
    WHEN NOT MATCHED THEN
        INSERT VALUES(MI.MEMBER_UID , MI.ITEM_ID, 1);
        
    UPDATE TB_MEMBER
    SET BALANCE = BALANCE - m_item_price
    WHERE TB_MEMBER.MEMBER_UID = p_member_uid;
    
END;
/

-- 아이템 사용 프로시저
CREATE OR REPLACE PROCEDURE USE_ITEM_PROC(
    p_member_uid IN NUMBER,
    p_item_id IN NUMBER
) IS
BEGIN
    -- 아이템 개수 차감
    UPDATE TB_MEMBER_ITEM
    SET ITEM_QTY = ITEM_QTY - 1
    WHERE MEMBER_UID = p_member_uid
        AND ITEM_ID = p_item_id
        AND ITEM_QTY > 0;

    -- SQL%ROWCOUNT : 가장 최근에 실행된 PL/SQL 문 SELECT 결과 갯수
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20004, '아이템 개수가 부족합니다.');
    END IF;
END;
/

/* 디버그용 코드
-- 컴파일 제대로 됬는지 확인
SELECT OBJECT_NAME, STATUS 
FROM USER_OBJECTS 
WHERE OBJECT_NAME = 'PURCHASE_STOCK_PROC';

-- 컴파일 확인 결과 INVALID일 경우 원인 보기
SELECT LINE, POSITION, TEXT 
FROM USER_ERRORS 
WHERE NAME = 'PURCHASE_STOCK_PROC';
*/

-- =============== 기본 데이터 삽입 ===================

-- ID(SEQ), NAME, PRICE, MAX_QTY, STOCK_QTY, STOCK_PRICE, NEXT_FLUCT
INSERT INTO TB_STOCK_LIST VALUES(STOCK_ID_SEQ.NEXTVAL,'LG전자', 112500, DEFAULT, DEFAULT);
INSERT INTO TB_STOCK_LIST VALUES(STOCK_ID_SEQ.NEXTVAL,'삼성전자', 159500, 1500, DEFAULT);
INSERT INTO TB_STOCK_LIST VALUES(STOCK_ID_SEQ.NEXTVAL,'롯데케미칼', 100800, DEFAULT, DEFAULT);
INSERT INTO TB_STOCK_LIST VALUES(STOCK_ID_SEQ.NEXTVAL,'현대모비스',224500, DEFAULT, DEFAULT);
INSERT INTO TB_STOCK_LIST VALUES(STOCK_ID_SEQ.NEXTVAL,'KB금융',84600, 800, DEFAULT);

-- MEMBER_RCODE, MEMBER_RNAME
INSERT INTO TB_MEMBER_RANK VALUES('M1','신규회원');
INSERT INTO TB_MEMBER_RANK VALUES('M2','일반회원');
INSERT INTO TB_MEMBER_RANK VALUES('M3','우수회원');
INSERT INTO TB_MEMBER_RANK VALUES('AD','관리자');

-- ID, NAME, PRICE, DESC
INSERT INTO TB_ITEM VALUES(1,'오늘의 운세',500,'오늘의 운세를 점쳐봅니다.(주가에 영향을 미치진 않습니다.)');
INSERT INTO TB_ITEM VALUES(2,'주가 예측 아이템',10000,'랜덤한 종목의 다음날 변동폭을 근사하게 알아냅니다.');

COMMIT;

-- ==========================
-- VO에 넣을 데이터 뽑아낼 쿼리
SELECT *
FROM TB_MEMBER_STOCK
JOIN TB_STOCK_LIST USING(STOCK_ID)
WHERE MEMBER_UID = 1;

SELECT *
FROM TB_SHARE
JOIN TB_STOCK_LIST USING(STOCK_ID)
WHERE MEMBER_UID = 1;

SELECT * 
FROM TB_MEMBER_ITEM
JOIN TB_ITEM USING (ITEM_ID)
WHERE MEMBER_UID = '1';

SELECT * 
FROM (
        SELECT 
            T.TRADE_ID,
            T.MEMBER_UID,
            T.TRADE_DATE,
            T.STOCK_ID,
            T.TRADE_QTY,
            T.TRADE_PRICE,
            T.TRADE_STATUS,
            S.STOCK_NAME,
            ROW_NUMBER() OVER(ORDER BY T.TRADE_DATE DESC) AS RNUM
        FROM TB_TRADELOG T
        JOIN TB_STOCK_LIST S ON T.STOCK_ID = S.STOCK_ID
        WHERE T.MEMBER_UID = 1
) WHERE RNUM BETWEEN 10 AND 20;

-- =========================
-- 디버깅용
UPDATE TB_MEMBER
SET BALANCE = 1000000
WHERE MEMBER_UID = 1;
COMMIT;

DELETE FROM TB_MEMBER_ITEM;
INSERT INTO TB_MEMBER_ITEM VALUES(1,1,3);
INSERT INTO TB_MEMBER_ITEM VALUES(1,2,2);

SELECT * FROM TB_ITEM ORDER BY ITEM_ID;

UPDATE TB_MEMBER_ITEM
SET ITEM_QTY =3
WHERE MEMBER_UID = 1;

COMMIT;

